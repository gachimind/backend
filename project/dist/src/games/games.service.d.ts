import { Repository } from 'typeorm';
import { KeywordService } from 'src/keyword/keyword.service';
import { PlayersService } from './players.service';
import { RoomService } from './room.service';
import { GameResult } from './entities/gameResult.entity';
import { Room } from './entities/room.entity';
import { TodayResult } from './entities/todayResult.entity';
import { Turn } from './entities/turn.entity';
import { TurnResult } from './entities/turnResult.entity';
import { TurnResultDataInsertDto } from './dto/turn-result.data.insert.dto';
import { Player } from './entities/player.entity';
import { NextFunction } from 'express';
import { Keyword } from 'src/keyword/entities/keyword.entities';
import { GamesRepository } from './games.repository';
import { GameMap } from './dto/game.map.dto';
export declare class GamesService {
    private readonly roomService;
    private readonly playersService;
    private readonly keywordsService;
    private readonly gamesRepository;
    private readonly playersRepository;
    private readonly turnRepository;
    private readonly turnResultRepository;
    private readonly gameResultRepository;
    private readonly todayResultRepository;
    constructor(roomService: RoomService, playersService: PlayersService, keywordsService: KeywordService, gamesRepository: GamesRepository, playersRepository: Repository<Player>, turnRepository: Repository<Turn>, turnResultRepository: Repository<TurnResult>, gameResultRepository: Repository<GameResult>, todayResultRepository: Repository<TodayResult>);
    getTurnsByRoomId(roomInfo: number): Promise<Turn[]>;
    getAllTurnsByRoomId(roomInfo: number): Promise<Turn[]>;
    getTurnByTurnId(turnId: number): Promise<Turn>;
    createTurn(roomId: number): Promise<Turn>;
    updateTurn(turn: Turn, timer: string): Promise<Turn>;
    deleteTurnByRoomId(roomInfo: number): Promise<void>;
    deleteTurnByTurnId(turnId: number): Promise<void>;
    createTurnResult(turnResult: TurnResultDataInsertDto): Promise<TurnResultDataInsertDto & TurnResult>;
    sumTurnScorePerPlayerByUserId(roomId: number, gameResultId: number): Promise<number>;
    createGameResultPerPlayer(roomId: number): Promise<GameResult[]>;
    updateGameResult(gameResultId: number, gameScore: number): Promise<{
        gameResultId: number;
        gameScore: number;
    } & GameResult>;
    softDeleteGameResult(gameResultId: number): Promise<import("typeorm").UpdateResult>;
    updateTodayResultByIncrement(todayResultId: number, gameScore: number): Promise<import("typeorm").UpdateResult>;
    recordPlayerScore(userId: number, room: Room): Promise<TurnResult>;
    createSpeechPlayerTurnResult(roomId: number, turn: Turn): Promise<number>;
    handleGameEndEvent(room: Room): Promise<Room>;
    createGameMap(room: Room, gameResults: GameResult[]): Promise<void>;
    popGameMapKeywords(roomId: number): Promise<Keyword>;
    getGameMapKeywordsCount(roomId: number): Promise<number>;
    getGameMapRemainingTurns(roomId: number): Promise<number>;
    getGameMapCurrentTurnId(roomId: number): Promise<number>;
    getGameMapCurrentTurn(roomId: number): Promise<number>;
    getGameMapCurrentPlayers(roomId: number): Promise<number>;
    getGameMapGameResultIdByUserId(roomId: number, userId: number): Promise<number>;
    updateGameMapCurrentTurn(roomId: number, turnId: number, turn: number): Promise<void>;
    reduceGameMapCurrentPlayers(roomId: number): Promise<void>;
    popPlayerFromGameMapRemainingTurns(roomId: number): Promise<number>;
    removePlayerFromGameMapRemainingTurns(roomId: number, userId: number): Promise<void>;
    mapGameResultIdWithUserId(gameResults: GameResult[], gameMap: GameMap): Promise<GameMap>;
    createTurnMap(roomId: number, turnId: number, keyword: Keyword): Promise<void>;
    getTurnMapKeyword(roomId: number): Promise<Keyword>;
    getTurnMapTurnQuizRank(roomId: number): Promise<number>;
    updateTurnMapSpeechScore(roomId: number, score: number): Promise<number>;
    updateTurnMapTurnQuizRank(roomId: number): Promise<void>;
    updateTurnMapNumberOfEvaluators(roomInfo: number): Promise<void>;
    createTimer(time: number, roomId: number): Promise<string>;
    breakTimer(roomId: number, next: NextFunction): Promise<void>;
}
